<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>lvs</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>true</show-in-menu>
 <group-name>lvs_scripts</group-name>
 <menu-path>tools_menu.lvs.end</menu-path>
 <interpreter>dsl</interpreter>
 <dsl-interpreter-name>lvs-dsl-xml</dsl-interpreter-name>
 <text>
require_relative "fc_model_builder"

#
# Extraction for SKY130
#
############################

tstart = Time.now
FASTERCAP = true

# optionnal for a batch launch :   klayout -b -rd input=my_layout.gds -rd report=my_report.lyrdb -rd schematic=reference_netlist.cir -rd target_netlist=extracted_netlist.cir -r sky130.lvs
if $input
  source($input)
end

if $report
  report($report)
else
  report_lvs("lvs_report.lvsdb")
end

if $schematic
#reference netlist
   schematic($schematic)
else 
   schematic("sky130hs_lib.cdl")
end

# true: use net names instead of numbers
# false: use numbers for nets
spice_with_net_names = true

# true: put in comments with details
# false: no comments
spice_with_comments = false

if $target_netlist
  target_netlist($target_netlist)
else
   # target_netlist("netlist.cir", write_spice(spice_with_net_names, spice_with_comments), "The netlist comment goes here.") 
   target_netlist(File.join(File.dirname(RBA::CellView::active.filename), source.cell_name+"_extracted.cir"), write_spice(spice_with_net_names, spice_with_comments),  "Extracted by KLayout on : #{Time.now.strftime("%d/%m/%Y %H:%M")}")
end

# Hierarchical mode
deep
# Use 4 CPU cores
threads(4)
# Print details
verbose(true)


# layers definitions
########################
BOUND  = polygons(235, 4)
DNWELL  = polygons(64, 18)
PWRES  = polygons(64, 13)
NWELL  = polygons(64, 20)
NWELLTXT  = input(64, 5)
NWELLPIN  = polygons(64, 16)
SUBTXT  = input(122, 5)
SUBPIN  = input(64, 59)
DIFF  = polygons(65, 20)
TAP  = polygons(65, 44)
PSDM  = polygons(94, 20)
NSDM  = polygons(93, 44)
LVTN  = polygons(125, 44)
HVTR  = polygons(18, 20)
HVTP  = polygons(78, 44)
SONOS  = polygons(80, 20)
COREID  = polygons(81, 2)
STDCELL  = polygons(81, 4)
NPNID  = polygons(82, 20)
PNPID  = polygons(82, 44)
RPM  = polygons(86, 20)
URPM  = polygons(79, 20)
LDNTM  = polygons(11, 44)
HVNTM  = polygons(125, 20)
POLY  = polygons(66, 20)
POLYTXT  = input(66, 5)
POLYPIN  = polygons(66, 16)
HVI  = polygons(75, 20)
LICON  = polygons(66, 44)
NPC  = polygons(95, 20)
DIFFRES  = polygons(65, 13)
POLYRES  = polygons(66, 13)
POLYSHO  = polygons(66, 15)
DIODE  = polygons(81, 23)
LI  = polygons(67, 20)
LITXT  = input(67, 5)
LIPIN  = polygons(67, 16)
LIRES  = polygons(67, 13)
MCON  = polygons(67, 44)
MET1  = polygons(68, 20)
MET1TXT  = input(68, 5)
MET1PIN  = polygons(68, 16)
MET1RES  = polygons(68, 13)
VIA1  = polygons(68, 44)
MET2  = polygons(69, 20)
MET2TXT  = input(69, 5)
MET2PIN  = polygons(69, 16)
MET2RES  = polygons(69, 13)
VIA2  = polygons(69, 44)
MET3  = polygons(70, 20)
MET3TXT  = input(70, 5)
MET3PIN  = polygons(70, 16)
MET3RES  = polygons(70, 13)
VIA3  = polygons(70, 44)
MET4  = polygons(71, 20)
MET4TXT  = input(71, 5)
MET4PIN  = polygons(71, 16)
MET4RES  = polygons(71, 13)
VIA4  = polygons(71, 44)
MET5  = polygons(72, 20)
MET5TXT  = input(72, 5)
MET5PIN  = polygons(72, 16)
MET5RES  = polygons(72, 13)
RDL  = polygons(74, 20)
RDLTXT  = input(74, 5)
RDLPIN  = polygons(74, 16)
GLASS  = polygons(76, 20)
CAPM  = polygons(89, 44)
CAPM2  = polygons(97, 44)
LOWTAPD  = polygons(81, 14)
FILLOBSM1  = polygons(62, 24)
FILLOBSM2  = polygons(105, 52)
FILLOBSM3  = polygons(107, 24)
FILLOBSM4  = polygons(112, 4)
NCM = polygons(92, 44)

# Bulk layer for terminal provisioning
SUB = polygons(236, 0)
# SUB = polygon_layer

# Computed layers
PDIFF = DIFF &amp; NWELL &amp; PSDM
NTAP = TAP &amp; NWELL &amp; NSDM
PGATE = PDIFF &amp; POLY
PSD = PDIFF - PGATE
STD_PGATE = PGATE - HVTP - NCM - HVI
HVT_PGATE = PGATE &amp; HVTP - NCM - HVI
HV5_PGATE = PGATE - HVTP - NCM &amp; HVI
  
NDIFF = DIFF - NWELL &amp; NSDM
PTAP = TAP - NWELL &amp; PSDM
NGATE = NDIFF &amp; POLY
NSD = NDIFF - NGATE
STD_NGATE = NGATE - NCM - LVTN - HVI
LVT_NGATE = NGATE - NCM &amp; LVTN - HVI
HV5_NGATE = NGATE - NCM - LVTN &amp; HVI
HV5NA_NGATE = NGATE - NCM &amp; LVTN &amp; HVI

# drawing to physical
device_scaling(1000000)

# PMOS transistor device extraction
extract_devices(mos4("pfet_01v8"), { "SD" =&gt; PSD, "G" =&gt; STD_PGATE, "tS" =&gt; PSD, "tD" =&gt; PSD, "tG" =&gt; POLY, "W" =&gt; NWELL })
extract_devices(mos4("pfet_01v8_hvt"), { "SD" =&gt; PSD, "G" =&gt; HVT_PGATE, "tS" =&gt; PSD, "tD" =&gt; PSD, "tG" =&gt; POLY, "W" =&gt; NWELL })
extract_devices(mos4("pfet_g5v0d10v5"), { "SD" =&gt; PSD, "G" =&gt; HV5_PGATE, "tS" =&gt; PSD, "tD" =&gt; PSD, "tG" =&gt; POLY, "W" =&gt; NWELL })

# NMOS transistor device extraction
extract_devices(mos4("nfet_01v8"), { "SD" =&gt; NSD, "G" =&gt; STD_NGATE, "tS" =&gt; NSD, "tD" =&gt; NSD, "tG" =&gt; POLY, "W" =&gt; SUB })
extract_devices(mos4("nfet_01v8_lvt"), { "SD" =&gt; NSD, "G" =&gt; LVT_NGATE, "tS" =&gt; NSD, "tD" =&gt; NSD, "tG" =&gt; POLY, "W" =&gt; SUB })
extract_devices(mos4("nfet_g5v0d10v5"), { "SD" =&gt; NSD, "G" =&gt; HV5_NGATE, "tS" =&gt; NSD, "tD" =&gt; NSD, "tG" =&gt; POLY, "W" =&gt; SUB })
extract_devices(mos4("nfet_01v8_nvt"), { "SD" =&gt; NSD, "G" =&gt; HV5NA_NGATE, "tS" =&gt; NSD, "tD" =&gt; NSD, "tG" =&gt; POLY, "W" =&gt; SUB })


# Define connectivity for netlist extraction

# Inter-layer
connect(SUB,  PTAP)
connect(NWELL,  NTAP)
connect(LICON,   PTAP)
connect(LICON,   NTAP)
connect(PSD,    LICON)
connect(NSD,    LICON)
connect(POLY,   LICON)
connect(LICON,   LI)
connect(LI, MCON)
connect(MCON,   MET1)
connect(MET1,VIA1)
connect(VIA1,   MET2)
connect(MET2, VIA2)
connect(VIA2,   MET3)
connect(MET3, VIA3)
connect(VIA3,   MET4)
connect(MET4, VIA4)
connect(VIA4,   MET5)
# Attaching labels
connect(SUB, SUBTXT)
connect(SUB, SUBPIN)
connect(NWELL, NWELLTXT)
connect(POLY, POLYTXT)
connect(LI, LITXT)
connect(MET1, MET1PIN)
connect(MET2, MET2PIN)
connect(MET3, MET3PIN)
connect(MET4, MET4PIN)
connect(MET5, MET5PIN)
connect(MET1PIN, MET1TXT)
connect(MET2PIN, MET2TXT)
connect(MET3PIN, MET3TXT)
connect(MET4PIN, MET4TXT)
connect(MET5PIN, MET5TXT)

# Global
connect_global(SUB, "VSS")
connect_implicit("VSS")

# Actually performs the extraction
netlist # ... not really required
split_gates("nfet_01v8")
split_gates("pfet_01v8_hvt")

# Flatten cells which are present in one netlist only
schematic.flatten_circuit("SKY130_FD_SC_HD__FILL_*")
schematic.flatten_circuit("SKY130_FD_SC_HD__TAP*")
schematic.flatten_circuit("SKY130_FD_SC_HD__CONB*")
align
# SIMPLIFICATION of the netlist
#netlist.make_top_level_pins
#netlist.combine_devices
#netlist.purge
#netlist.purge_nets
netlist.simplify
schematic.simplify

# Tolerances for the devices extracted parameters
#  tolerance(device_class_name, parameter_name [, :absolute =&gt; absolute_tolerance] [, :relative =&gt; relative_tolerance])
tolerance("pfet_01v8", "W", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("pfet_01v8", "L", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("pfet_01v8_hvt", "W", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("pfet_01v8_hvt", "L", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("nfet_01v8", "W", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("nfet_01v8", "L", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("nfet_01v8_lvt", "W", :absolute =&gt; 1.nm, :relative =&gt; 0.001)
tolerance("nfet_01v8_lvt", "L", :absolute =&gt; 1.nm, :relative =&gt; 0.001)

# NangateOpenCellLibrary Digital gates input equivalence :
equivalent_pins("*AND2_1", "A", "B")
equivalent_pins("*AND2_2", "A", "B")
equivalent_pins("*AND2_4", "A", "B")
equivalent_pins("*AND3_1", "A", "B", "C")
equivalent_pins("*AND3_2", "A", "B", "C")
equivalent_pins("*AND3_4", "A", "B", "C")
equivalent_pins("*AND4_1", "A", "B", "C", "D")
equivalent_pins("*AND4_2", "A", "B", "C", "D")
equivalent_pins("*AND4_4", "A", "B", "C", "D")
equivalent_pins("*NAND2_1", "A", "B")
equivalent_pins("*NAND2_2", "A", "B")
equivalent_pins("*NAND2_4", "A", "B")
equivalent_pins("*NAND3_1", "A", "B", "C")
equivalent_pins("*NAND3_2", "A", "B", "C")
equivalent_pins("*NAND3_4", "A", "B", "C")
equivalent_pins("*NAND4_X1", "A", "B", "C", "D")
equivalent_pins("*NAND4_2", "A", "B", "C", "D")
equivalent_pins("*NAND4_4", "A", "B", "C", "D")
equivalent_pins("*OR2_1", "A", "B")
equivalent_pins("*OR2_2", "A", "B")
equivalent_pins("*OR2_4", "A", "B")
equivalent_pins("*OR3_1", "A", "B", "C")
equivalent_pins("*OR3_2", "A", "B", "C")
equivalent_pins("*OR3_4", "A", "B", "C")
equivalent_pins("*OR4_1", "A", "B", "C", "D")
equivalent_pins("*OR4_2", "A", "B", "C", "D")
equivalent_pins("*OR4_4", "A", "B", "C", "D")
equivalent_pins("*NOR2_1", "A", "B")
equivalent_pins("*NOR2_2", "A", "B")
equivalent_pins("*NOR2_4", "A", "B")
equivalent_pins("*NOR3_1", "A", "B", "C")
equivalent_pins("*NOR3_2", "A", "B", "C")
equivalent_pins("*NOR3_4", "A", "B", "C")
equivalent_pins("*NOR4_1", "A", "B", "C", "D")
equivalent_pins("*NOR4_2", "A", "B", "C", "D")
equivalent_pins("*NOR4_4", "A", "B", "C", "D")
equivalent_pins("*XOR2_1", "A", "B")
equivalent_pins("*XOR2_2", "A", "B")
equivalent_pins("*XNOR2_1", "A", "B")
equivalent_pins("*XNOR2_2", "A", "B")

#max_res(1000000)
#min_caps(1e-15)

if ! compare 
  #raise "ERROR : Netlists don't match"
  puts "ERROR : Netlists don't match"
else
  puts "INFO : Congratulations! Netlists match."
end


##########  PARASITIC CAPACITORS EXTRACTION based on FASTERCAP

if FASTERCAP &amp;&amp; compare

  def net_name(net)
    if net.is_a?(String)
      net
    else
      net ? net.expanded_name : "0"
    end
  end
  
  def ds(cs, symbol, defs)
    cs[symbol] = defs
    if defs[:z_on]
      defs[:z_bot] = cs[defs[:z_on]][:z_top]
    end
    if defs[:z_height]
      defs[:z_top] = defs[:z_bot] + defs[:z_height]
    else
      defs[:z_height] = defs[:z_top] - defs[:z_bot]   
    end
  end
  
  # describes the conductor stack
  cond_stack = {}
  
  # should be included in device models:
  #ds(cond_stack, :PTAP,  { :z_bot =&gt; -120.nm, :z_top   =&gt; 0.nm })
  #ds(cond_stack, :NTAP,  { :z_bot =&gt; -120.nm, :z_top   =&gt; 0.nm })
  #ds(cond_stack, :PSD,   { :z_bot =&gt; -120.nm, :z_top   =&gt; 0.nm })
  #ds(cond_stack, :NSD,   { :z_bot =&gt; -120.nm, :z_top   =&gt; 0.nm })
  ds(cond_stack, :POLY,  { :z_bot =&gt; 5.nm,    :z_height =&gt; 180.nm })
  ds(cond_stack, :LICON, { :z_bot =&gt; 0.nm,    :z_top    =&gt; 615.nm })
  ds(cond_stack, :LICON_ON_POLY, { :z_on  =&gt; :POLY,  :z_top    =&gt; 615.nm })
  ds(cond_stack, :LI,    { :z_on  =&gt; :LICON,  :z_height =&gt; 100.nm })
  ds(cond_stack, :MCON,  { :z_on  =&gt; :LI,     :z_height =&gt; 340.nm })
  ds(cond_stack, :MET1,  { :z_on  =&gt; :MCON,   :z_height =&gt; 360.nm })
  ds(cond_stack, :VIA1,  { :z_on  =&gt; :MET1,   :z_height =&gt; 270.nm })
  ds(cond_stack, :MET2,  { :z_on  =&gt; :VIA1,   :z_height =&gt; 360.nm })
  ds(cond_stack, :VIA2,  { :z_on  =&gt; :MET2,   :z_height =&gt; 420.nm })
  ds(cond_stack, :MET3,  { :z_on  =&gt; :VIA2,   :z_height =&gt; 845.nm })
  ds(cond_stack, :VIA3,  { :z_on  =&gt; :MET3,   :z_height =&gt; 390.nm })
  ds(cond_stack, :MET4,  { :z_on  =&gt; :VIA3,   :z_height =&gt; 845.nm })
  ds(cond_stack, :VIA4,  { :z_on  =&gt; :MET4,   :z_height =&gt; 505.nm })
  ds(cond_stack, :MET5,  { :z_on  =&gt; :VIA4,   :z_height =&gt; 1.26   })

  # default k is 3.9
  fcm = FCModelBuilder::new(3.9, dbu, amax: 0.5, b: 0.5)

  fcm.add_material("SPNIT", 7.5)
  fcm.add_material("LINT", 7.3)
  fcm.add_material("NILD2", 4.05)
  fcm.add_material("NILD3", 4.5)
  fcm.add_material("NILD4", 4.2)
  fcm.add_material("NILD5", 4.1)
  fcm.add_material("NILD6", 4.0)
  fcm.add_material("TOPNIT", 7.5)
  fcm.add_material("PI1", 2.94)
  
  # @@@ TODO: cannot have hierarchy as of now. COULD, if we 
  # had a way to hierarchically identify the subcircuit and iterate
  # over every one of them. But then patching back the nets will be
  # a problem.
  netlist.each_circuit_top_down do |circuit|
  
    circuit.each_net do |net|
    
      nn = net.expanded_name()
      
      # outputs the shapes for this net to layers : poly, contacts, metals, vias :
      shapes = {}
      [ 
        # :PTAP, :NTAP, :PSD, :NSD,  - should be included in device models
        :POLY, :LICON, :LI, :MCON, 
        :MET1, :VIA1, :MET2, :VIA2, :MET3, :VIA3, :MET4
      ].each do |ln|
        shapes[ln] = l2n_data.shapes_of_net(net, eval(ln.to_s).data, true)
      end
      
      shapes[:LICON_ON_POLY] = shapes[:LICON] &amp; shapes[:POLY]
      shapes[:LICON] -= shapes[:POLY]
      
      shapes.each do |ln,s|
        fcm.add_conductor(s, nn, z: cond_stack[ln][:z_bot], h: cond_stack[ln][:z_height])
      end
      
    end # for net
    
    break # @@@ no hierarchy as of now!
    
  end # for circuit
    
  # some global substrate below, not counting the device areas
  # @@@ TODO: this is a rough approximation!
  fcm.add_conductor(SUB - DIFF - TAP, "0", z: -430.nm, h: 100.nm)

  # Add dielectrics

if false # @@@ 
  # SPNIT
  poly_sized2 = POLY.sized(43.nm)
  poly_sized1 = poly_sized2 - POLY.sized(6.nm)
  fcm.add_dielectric(poly_sized1, "SPNIT", z: cond_stack[:POLY][:z_bot], h: cond_stack[:POLY][:z_height])
  fcm.add_dielectric(poly_sized2, "SPNIT", z: cond_stack[:POLY][:z_top], h: 121.nm)
  
  # LINT
  li_sized1 = LI.sized(75.nm)
  fcm.add_dielectric(SUB, "LINT", z: cond_stack[:LI][:z_bot], h: 75.nm)
  fcm.add_dielectric(li_sized1, "LINT", z: cond_stack[:LI][:z_bot], h: cond_stack[:LI][:z_height] + 75.nm)
  
  # NILD2
  fcm.add_dielectric(SUB, "NILD2", z: cond_stack[:LI][:z_bot], h: cond_stack[:MCON][:z_top] - cond_stack[:LI][:z_bot])
  
  # NILD3
  fcm.add_dielectric(SUB, "NILD3", z: cond_stack[:MET1][:z_bot], h: cond_stack[:VIA1][:z_top] - cond_stack[:MET1][:z_bot])
  
  # NILD4
  fcm.add_dielectric(SUB, "NILD4", z: cond_stack[:MET2][:z_bot], h: cond_stack[:VIA2][:z_top] - cond_stack[:MET2][:z_bot])
  
  # NILD5
  fcm.add_dielectric(SUB, "NILD5", z: cond_stack[:MET3][:z_bot], h: cond_stack[:VIA3][:z_top] - cond_stack[:MET3][:z_bot])
  
  # NILD6
  fcm.add_dielectric(SUB, "NILD6", z: cond_stack[:MET4][:z_bot], h: cond_stack[:VIA4][:z_top] - cond_stack[:MET4][:z_bot])
  
  # TOPNIT
  metal5_sized1 = SUB - MET5.sized(70.nm)
  metal5_sized2 = MET5.sized(490.nm)
  metal5_sized3 = metal5_sized1 &amp; metal5_sized2
  fcm.add_dielectric(metal5_sized3, "TOPNIT", z: cond_stack[:MET5][:z_bot], h: 380.nm)
  fcm.add_dielectric(metal5_sized2, "TOPNIT", z: cond_stack[:MET5][:z_bot], h: 1.35)
  fcm.add_dielectric(metal5_sized2, "TOPNIT", z: cond_stack[:MET5][:z_bot] + 1.35, h: 540.nm)
  
  # PI1
  fcm.add_dielectric(SUB, "PI1", z: cond_stack[:MET5][:z_bot], h: 6.39)
end # @@@

  # write file  
  gen = fcm.generate
  
  # for debugging
  gen.dump_stl

  # write fastcap file
  file_FCinput = File.join(File.dirname(RBA::CellView::active.filename), source.cell_name+"_FasterCapInput")
  gen.write_fastcap(file_FCinput)
  
if false
  
  # now launch Fastercap !
  system("FasterCap -a0.01 -b " + file_FCinput + ".lst &gt;" + File.join(File.dirname(RBA::CellView::active.filename), source.cell_name+"_FasterCapOutput.txt"))
  
  dimension = 0
  j = 0
  capex_mat = Array.new{Array.new}
  capname = Array.new
  
  # Open the FasterCap output file to extract the Maxwell Capacitors matrix
  file_FCoutput = File.join(File.dirname(RBA::CellView::active.filename), source.cell_name+"_FasterCapOutput.txt")
  File.open(file_FCoutput, "r") do |file|
    file.each_line do |line|
      line = line.encode("UTF-8", :invalid =&gt; :replace, :undef =&gt; :replace)
      i = 0
      if (j&gt;0 &amp;&amp; j&lt;dimension+1)
        for cap in line.split(' ') do
          #print(cap + " = ")
          if (i == 0)
            capname[j] = cap
          else
            capex_mat[i][j] = cap.to_f/1e6
          end
          i = i+1
        end # for
        j = j + 1
      end # if j

      if (line[0..8] == "Dimension")
        dimension = line.split(' ')[3].to_i
        print("cap_matrix dimension = " + dimension.to_s + "\n")
        capex_mat = Array.new(dimension+1){Array.new(dimension+1)}
        j = 1
      end # if split
    end # each line
  end # do file

  # embed the capacitances into the netlist
  top_circuit = netlist.circuit_by_name(source.cell_name)

  # create a capacitor class
  cap = RBA::DeviceClassCapacitor::new
  cap.name = "PEX_CAP"
  cap.description = "Extracted by PEX"
  netlist.add(cap)

  # build a name to net table  
  name2net = {}
  top_circuit.each_net do |n|
    name2net[n.expanded_name] = n
  end
  
  # find nets for the matrix axes
  nets = []
  (1..dimension).each do |i|
    nn = capname[i].split("_")[1]
    n = name2net[nn]
    n || raise("No net found with name #{nn}")
    nets[i] = n
  end
  
  nets[0] = top_circuit.create_net("0")
 
  # insert the caps
  (1..dimension).each do |j|
  
    capii = 0
    
    (1..dimension).each do |i|
    
      if i &gt; j
      
        n1 = nets[i]
        n2 = nets[j]
        c = top_circuit.create_device(cap, "Cext" + i.to_s + j.to_s)
        c.connect_terminal("A", n1)
        c.connect_terminal("B", n2)
        c.set_parameter("C", -capex_mat[i][j])
        
      else
      
        capii = capii + capex_mat[i][j]
        
      end # if i=j
      
    end # for i
    
    n1 = nets[j]
    n2 = nets[0]
    c = top_circuit.create_device(cap, "Cext" + j.to_s + j.to_s)
    c.connect_terminal("A", n1)
    c.connect_terminal("B", n2)
    c.set_parameter("C", capii)

  end # for j

end # @@@

end # if FASTERCAP


time = Time.now
hours = ((time - tstart)/3600).to_i
minutes = ((time - tstart)/60 - hours * 60).to_i
seconds = ((time - tstart) - (minutes * 60 + hours * 3600)).to_i
$stdout.write "LVS finished at : #{time.hour}:#{time.min}:#{time.sec}  -  LVS duration =  #{hours} hrs. #{minutes} min. #{seconds} sec.\n"</text>
</klayout-macro>
